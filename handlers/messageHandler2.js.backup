const fs = require('fs');
const path = require('path');
const { logger, adminNumbers } = require('../config');
const { isGroupChat, isBroadcast, isPrivateChat } = require('../utils/chatUtils');
const { messageStats, getStatsText } = require('../utils/messageStats');
const { formatCurrency } = require('../utils/formatter');
const { OCRStateManager } = require('../utils/ocrStateManager');
const { handleOCRCommand, handleOCRImage, handleOCRConfirmation } = require('./ocrHandler');
const { 
  handleAttendanceCommand,
  handleAttendanceChoice,
  handleAttendanceLocation,
  handleAttendancePhoto,
  handleAttendanceCancel,
  AttendanceStateManager
} = require('./attendanceHandler');
const { handleAdminCommand } = require('./adminHandler');
const { 
  isWhitelisted, 
  getUser, 
  addToWhitelist, 
  removeFromWhitelist,
  getWhitelist,
  isAuthorized
} = require('../services/userService');
const { 
  userHasPermission, 
  userCanUseCommand,
  userCanUseShortcut,
  userCanUseQuickNumber
} = require('../services/roleService');
const { 
  parseTransaction, 
  addTransaction,
  getTransactions,
  getTransactionsByCategory,
  getCategorySummary,
  deleteTransaction
} = require('../services/transactionService');
const {
  generateReport,
  generateCategoryReport,
  generateCategorySummaryReport,
  generateQuickMenu,
  getHelpText
} = require('../services/reportService');
const {
  generateQuickChart,
  generateTextChart
} = require('../services/chartService');

// Send image with proper media handling  
async function sendImageMessage(sock, jid, imagePath, caption) {
  try {
    // Read the image file
    const imageBuffer = fs.readFileSync(imagePath);
    
    // Send image message
    await sock.sendMessage(jid, {
      image: imageBuffer,
      caption: caption
    });
    
    logger.info('Image sent successfully', { 
      to: jid.split('@')[0], 
      imagePath: path.basename(imagePath),
      size: imageBuffer.length 
    });
    
    return true;
  } catch (error) {
    logger.error('Error sending image', { 
      to: jid.split('@')[0], 
      imagePath, 
      error: error.message 
    });
    return false;
  }
}

// Handle quick number commands (Finance role)
async function handleQuickNumber(sock, sender, user, quickNumber) {
  switch (quickNumber) {
    case 1: // /saldo
      const dayTransactions = await getTransactions(user.id, 'day');
      const dayReport = generateReport(dayTransactions, 'HARI INI');
      await sock.sendMessage(sender, { text: dayReport });
      break;
      
    case 2: // /bulan
      const monthTransactions = await getTransactions(user.id, 'month');
      const monthReport = generateReport(monthTransactions, 'BULAN INI');
      await sock.sendMessage(sender, { text: monthReport });
      break;
      
    case 3: // /kategori
      const categorySummary = await getCategorySummary(user.id, 'month');
      const summaryReport = generateCategorySummaryReport(categorySummary, 'BULAN INI');
      await sock.sendMessage(sender, { text: summaryReport });
      break;
      
    case 4: // /chart - line chart
      await sock.sendMessage(sender, { text: 'ğŸ“Š Membuat grafik trend... Mohon tunggu sebentar' });
      
      // Try QuickChart API first
      let chartPath = await generateQuickChart(user.id, 'line', 'month');
      
      if (chartPath) {
        messageStats.chartsGenerated++;
        const monthTransactions = await getTransactions(user.id, 'month');
        const income = monthTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const expense = monthTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        
        const caption = `ğŸ“ˆ *Grafik Trend Keuangan Bulanan*\n\nğŸ’° Total Pemasukan: ${formatCurrency(income)}\nğŸ’¸ Total Pengeluaran: ${formatCurrency(expense)}\nğŸ“Š Net: ${formatCurrency(income - expense)}`;
        
        const sent = await sendImageMessage(sock, sender, chartPath, caption);
        if (!sent) {
          // Fallback to text chart
          const textChart = await generateTextChart(user.id, 'line', 'month');
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        // Fallback to text chart
        const textChart = await generateTextChart(user.id, 'line', 'month');
        await sock.sendMessage(sender, { text: textChart });
      }
      break;
      
    case 5: // /pie - pie chart
      await sock.sendMessage(sender, { text: 'ğŸ¥§ Membuat pie chart... Mohon tunggu sebentar' });
      
      let pieChartPath = await generateQuickChart(user.id, 'pie', 'month');
      
      if (pieChartPath) {
        messageStats.chartsGenerated++;
        const categorySummary = await getCategorySummary(user.id, 'month');
        const expenseData = categorySummary.filter(s => s.type === 'expense');
        const total = expenseData.reduce((sum, s) => sum + s.total, 0);
        
        const caption = `ğŸ¥§ *Breakdown Pengeluaran Bulanan*\n\nğŸ’¸ Total: ${formatCurrency(total)}\nğŸ“Š Kategori: ${expenseData.length}`;
        
        const sent = await sendImageMessage(sock, sender, pieChartPath, caption);
        if (!sent) {
          const textChart = await generateTextChart(user.id, 'pie', 'month');
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        const textChart = await generateTextChart(user.id, 'pie', 'month');
        await sock.sendMessage(sender, { text: textChart });
      }
      break;
      
    case 6: // /compare - bar chart
      await sock.sendMessage(sender, { text: 'ğŸ“Š Membuat grafik perbandingan... Mohon tunggu sebentar' });
      
      let barChartPath = await generateQuickChart(user.id, 'bar', 'month');
      
      if (barChartPath) {
        messageStats.chartsGenerated++;
        const currentMonth = await getTransactions(user.id, 'month');
        const currentIncome = currentMonth.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const currentExpense = currentMonth.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        
        const caption = `ğŸ“Š *Perbandingan 3 Bulan Terakhir*\n\nğŸ“… Bulan Ini:\nğŸ’° Pemasukan: ${formatCurrency(currentIncome)}\nğŸ’¸ Pengeluaran: ${formatCurrency(currentExpense)}`;
        
        const sent = await sendImageMessage(sock, sender, barChartPath, caption);
        if (!sent) {
          const textChart = await generateTextChart(user.id, 'bar', 'month');
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        const textChart = await generateTextChart(user.id, 'bar', 'month');
        await sock.sendMessage(sender, { text: textChart });
      }
      break;
      
    case 7: // m [jumlah] - makan
      await sock.sendMessage(sender, { 
        text: 'ğŸ½ï¸ *INPUT MAKAN*\n\nFormat: m [jumlah]\nContoh: m 25000 atau m 25rb\n\nKetik sekarang:' 
      });
      break;
      
    case 8: // t [jumlah] - transport
      await sock.sendMessage(sender, { 
        text: 'ğŸš— *INPUT TRANSPORT*\n\nFormat: t [jumlah]\nContoh: t 15000 atau t 15rb\n\nKetik sekarang:' 
      });
      break;
      
    case 9: // g [jumlah] - gaji
      await sock.sendMessage(sender, { 
        text: 'ğŸ’° *INPUT GAJI*\n\nFormat: g [jumlah]\nContoh: g 5jt atau g 5000000\n\nKetik sekarang:' 
      });
      break;
      
    case 0: // /hapus
      await sock.sendMessage(sender, { 
        text: 'ğŸ—‘ï¸ *HAPUS TRANSAKSI*\n\nFormat: /hapus [ID]\nContoh: /hapus 123\n\nCek ID transaksi di laporan (/saldo atau /bulan)' 
      });
      break;
  }
  
  logger.debug('Quick command executed', { 
    to: sender.split('@')[0], 
    number: quickNumber,
    role: user.role?.name 
  });
}

// Handle shortcut commands (Finance role)
async function handleShortcutCommand(sock, sender, user, text) {
  const [shortcut, ...amountParts] = text.toLowerCase().split(' ');
  const amountText = amountParts.join(' ');
  
  let transactionText = '';
  switch (shortcut) {
    case 'm':
      transactionText = `bayar makan ${amountText}`;
      break;
    case 't':
      transactionText = `bayar transport ${amountText}`;
      break;
    case 'g':
      transactionText = `terima gaji ${amountText}`;
      break;
  }
  
  // Process as regular transaction
  const parsed = parseTransaction(transactionText);
  
  if (parsed) {
    messageStats.transactions++;
    const transactionId = await addTransaction(user.id, parsed);
    
    if (transactionId) {
      const sign = parsed.type === 'income' ? '+' : '-';
      
      const response = `âœ… *Transaksi Cepat Ditambahkan*

ğŸ“„ ID: #${transactionId}
ğŸ’° ${sign}${formatCurrency(parsed.amount)}
ğŸ“‚ ${parsed.category}
ğŸ“ ${parsed.description}

Ketik /saldo untuk cek saldo`;
      
      await sock.sendMessage(sender, { text: response });
      
      logger.info('Quick transaction processed', {
        transactionId,
        userId: user.id,
        shortcut,
        type: parsed.type,
        amount: parsed.amount,
        role: user.role?.name,
        from: sender.split('@')[0]
      });
    } else {
      await sock.sendMessage(sender, { text: 'âŒ Gagal menambahkan transaksi' });
    }
  } else {
    await sock.sendMessage(sender, { 
      text: `âŒ Format salah untuk ${shortcut.toUpperCase()}\n\nContoh yang benar:\nâ€¢ ${shortcut} 25000\nâ€¢ ${shortcut} 50rb\nâ€¢ ${shortcut} 2jt` 
    });
  }
}

// Handle cashier shortcuts (future implementation)
async function handleCashierShortcut(sock, sender, user, text) {
  const [shortcut, ...parts] = text.toLowerCase().split(' ');
  
  switch (shortcut) {
    case 'j': // jual
      await sock.sendMessage(sender, { 
        text: 'ğŸª Fitur penjualan akan segera tersedia!\n\nFormat: j [item] [harga]\nContoh: j minuman 5000' 
      });
      break;
      
    case 's': // stok
      await sock.sendMessage(sender, { 
        text: 'ğŸ“¦ Fitur stok akan segera tersedia!\n\nFormat: s [item] [jumlah]\nContoh: s minuman 50' 
      });
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: 'âŒ Shortcut kasir tidak dikenal' 
      });
  }
  
  logger.debug('Cashier shortcut executed', { 
    to: sender.split('@')[0], 
    shortcut,
    role: user.role?.name 
  });
}

// Role-based command handler
async function handleRoleBasedCommand(sock, sender, user, command, args) {
  const userNumber = sender.split('@')[0];
  
  // Check if user has role
  if (!user.role) {
    await sock.sendMessage(sender, { 
      text: `âŒ Anda belum memiliki role yang terdaftar.\n\nHubungi administrator untuk mendapatkan akses.\n\nğŸ“± Nomor Anda: ${userNumber}`
    });
    return;
  }
  
  // Check command permission
  const canUse = await userCanUseCommand(user.id, `/${command}`);
  if (!canUse) {
    await sock.sendMessage(sender, { 
      text: `âŒ Command /${command} tidak tersedia untuk role ${user.role.emoji} ${user.role.display_name}\n\nKetik /help untuk melihat command yang tersedia.`
    });
    return;
  }
  
  logger.info('Role-based command received', { 
    from: userNumber, 
    command, 
    role: user.role.name,
    userId: user.id,
    args: args.join(' ') 
  });
  
  // Route to appropriate handler based on role and command
  switch (user.role.name) {
    case 'finance':
      await handleFinanceCommand(sock, sender, user, command, args);
      break;
      
    case 'attendance':
      if (command === 'absen') {
        await handleAttendanceCommand(sock, sender, userNumber, args);
      } else {
        await handleAttendanceOnlyCommand(sock, sender, user, command, args);
      }
      break;
      
    case 'cashier':
      await handleCashierCommand(sock, sender, user, command, args);
      break;
      
    case 'admin':
      // Admin can access all commands, route based on command type
      if (['saldo', 'bulan', 'kategori', 'chart', 'pie', 'compare', 'hapus', 'ocr'].includes(command)) {
        await handleFinanceCommand(sock, sender, user, command, args);
      } else if (command === 'absen') {
        await handleAttendanceCommand(sock, sender, userNumber, args);
      } else if (['jual', 'stok', 'laporan'].includes(command)) {
        await handleCashierCommand(sock, sender, user, command, args);
      } else if (['role', 'users', 'admin'].includes(command)) {
        await handleAdminCommand(sock, sender, user, command, args);
      } else {
        await handleGeneralCommand(sock, sender, user, command, args);
      }
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: `âŒ Role "${user.role.display_name}" tidak dikenali. Hubungi administrator.` 
      });
  }
}

// Finance-specific command handler
async function handleFinanceCommand(sock, sender, user, command, args) {
  switch (command.toLowerCase()) {
    case 'help':
      const financeHelp = generateFinanceHelp();
      await sock.sendMessage(sender, { text: financeHelp });
      break;
      
    case 'menu':
      const financeMenu = generateFinanceMenu();
      await sock.sendMessage(sender, { text: financeMenu });
      messageStats.quickMenuUsage++;
      break;
      
    case 'saldo':
    case 'hari':
      const dayTransactions = await getTransactions(user.id, 'day');
      const dayReport = generateReport(dayTransactions, 'HARI INI');
      await sock.sendMessage(sender, { text: dayReport });
      break;
      
    case 'bulan':
      const monthTransactions = await getTransactions(user.id, 'month');
      const monthReport = generateReport(monthTransactions, 'BULAN INI');
      await sock.sendMessage(sender, { text: monthReport });
      break;

    case 'kategori':
      if (args.length === 0) {
        const categorySummary = await getCategorySummary(user.id, 'month');
        const summaryReport = generateCategorySummaryReport(categorySummary, 'BULAN INI');
        await sock.sendMessage(sender, { text: summaryReport });
      } else {
        const category = args.join(' ');
        const categoryTransactions = await getTransactionsByCategory(user.id, category, 'month');
        const categoryReport = generateCategoryReport(categoryTransactions, category, 'BULAN INI');
        await sock.sendMessage(sender, { text: categoryReport });
      }
      break;

    case 'chart':
      const period = args[0] || 'month';
      await sock.sendMessage(sender, { text: 'ğŸ“Š Membuat grafik trend... Mohon tunggu sebentar' });
      
      let lineChartPath = await generateQuickChart(user.id, 'line', period);
      
      if (lineChartPath) {
        messageStats.chartsGenerated++;
        const transactions = await getTransactions(user.id, period);
        const income = transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const expense = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        
        const caption = `ğŸ“ˆ *Grafik Trend Keuangan*\nPeriode: ${period}\n\nğŸ’° Pemasukan: ${formatCurrency(income)}\nğŸ’¸ Pengeluaran: ${formatCurrency(expense)}`;
        
        const sent = await sendImageMessage(sock, sender, lineChartPath, caption);
        if (!sent) {
          const textChart = await generateTextChart(user.id, 'line', period);
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        const textChart = await generateTextChart(user.id, 'line', period);
        await sock.sendMessage(sender, { text: textChart });
      }
      break;

    case 'pie':
      await sock.sendMessage(sender, { text: 'ğŸ¥§ Membuat pie chart pengeluaran... Mohon tunggu sebentar' });
      
      let pieChartPath = await generateQuickChart(user.id, 'pie', 'month');
      
      if (pieChartPath) {
        messageStats.chartsGenerated++;
        const categorySummary = await getCategorySummary(user.id, 'month');
        const expenseData = categorySummary.filter(s => s.type === 'expense');
        const total = expenseData.reduce((sum, s) => sum + s.total, 0);
        
        const caption = `ğŸ¥§ *Breakdown Pengeluaran Bulanan*\n\nğŸ’¸ Total: ${formatCurrency(total)}\nğŸ“Š Kategori: ${expenseData.length}`;
        
        const sent = await sendImageMessage(sock, sender, pieChartPath, caption);
        if (!sent) {
          const textChart = await generateTextChart(user.id, 'pie', 'month');
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        const textChart = await generateTextChart(user.id, 'pie', 'month');
        await sock.sendMessage(sender, { text: textChart });
      }
      break;

    case 'compare':
      await sock.sendMessage(sender, { text: 'ğŸ“Š Membuat grafik perbandingan... Mohon tunggu sebentar' });
      
      let barChartPath = await generateQuickChart(user.id, 'bar', 'month');
      
      if (barChartPath) {
        messageStats.chartsGenerated++;
        const currentMonth = await getTransactions(user.id, 'month');
        const currentIncome = currentMonth.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const currentExpense = currentMonth.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        
        const caption = `ğŸ“Š *Perbandingan 3 Bulan Terakhir*\n\nğŸ“… Bulan Ini:\nğŸ’° Pemasukan: ${formatCurrency(currentIncome)}\nğŸ’¸ Pengeluaran: ${formatCurrency(currentExpense)}`;
        
        const sent = await sendImageMessage(sock, sender, barChartPath, caption);
        if (!sent) {
          const textChart = await generateTextChart(user.id, 'bar', 'month');
          await sock.sendMessage(sender, { text: textChart });
        }
      } else {
        const textChart = await generateTextChart(user.id, 'bar', 'month');
        await sock.sendMessage(sender, { text: textChart });
      }
      break;

    case 'hapus':
      if (args[0] && !isNaN(args[0])) {
        const deleted = await deleteTransaction(args[0], user.id);
        if (deleted) {
          await sock.sendMessage(sender, { text: `âœ… Transaksi #${args[0]} dihapus` });
          logger.info('Transaction deleted via command', { 
            transactionId: args[0], 
            userId: user.id, 
            role: user.role.name,
            requestedBy: sender.split('@')[0] 
          });
        } else {
          await sock.sendMessage(sender, { text: 'âŒ Transaksi tidak ditemukan' });
        }
      } else {
        await sock.sendMessage(sender, { text: 'âŒ Format: /hapus [ID]' });
      }
      break;

    case 'ocr':
      await handleOCRCommand(sock, { key: { remoteJid: sender } }, sender.split('@')[0]);
      break;

    case 'stats':
      let statsText = getStatsText();
      statsText += `\nğŸ” OCR Processed: ${messageStats.ocrProcessed || 0}`;
      await sock.sendMessage(sender, { text: statsText });
      messageStats.commands++;
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: 'âŒ Command tidak dikenal untuk role Keuangan. Ketik /help untuk bantuan.' 
      });
  }
}

// Attendance-only command handler
async function handleAttendanceOnlyCommand(sock, sender, user, command, args) {
  switch (command.toLowerCase()) {
    case 'help':
      const attendanceHelp = generateAttendanceHelp();
      await sock.sendMessage(sender, { text: attendanceHelp });
      break;
      
    case 'menu':
      const attendanceMenu = generateAttendanceMenu();
      await sock.sendMessage(sender, { text: attendanceMenu });
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: 'âŒ Command tidak dikenal untuk role Absensi. Ketik /help untuk bantuan.' 
      });
  }
}

// Cashier command handler (future implementation)
async function handleCashierCommand(sock, sender, user, command, args) {
  switch (command.toLowerCase()) {
    case 'help':
      const cashierHelp = generateCashierHelp();
      await sock.sendMessage(sender, { text: cashierHelp });
      break;
      
    case 'menu':
      const cashierMenu = generateCashierMenu();
      await sock.sendMessage(sender, { text: cashierMenu });
      break;
      
    case 'jual':
      await sock.sendMessage(sender, { 
        text: 'ğŸª Fitur penjualan akan segera tersedia!' 
      });
      break;
      
    case 'stok':
      await sock.sendMessage(sender, { 
        text: 'ğŸ“¦ Fitur stok akan segera tersedia!' 
      });
      break;
      
    case 'laporan':
      await sock.sendMessage(sender, { 
        text: 'ğŸ“Š Fitur laporan kasir akan segera tersedia!' 
      });
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: 'âŒ Command tidak dikenal untuk role Kasir. Ketik /help untuk bantuan.' 
      });
  }
}

// General commands (help, menu, stats)
async function handleGeneralCommand(sock, sender, user, command, args) {
  switch (command.toLowerCase()) {
    case 'help':
      const roleSpecificHelp = generateRoleSpecificHelp(user.role);
      await sock.sendMessage(sender, { text: roleSpecificHelp });
      break;
      
    case 'menu':
      const roleSpecificMenu = generateRoleSpecificMenu(user.role);
      await sock.sendMessage(sender, { text: roleSpecificMenu });
      break;
      
    case 'stats':
      if (user.role.name === 'admin') {
        let statsText = getStatsText();
        statsText += `\nğŸ” OCR Processed: ${messageStats.ocrProcessed || 0}`;
        statsText += `\nğŸ‘¥ Active OCR Sessions: ${OCRStateManager.getActiveStatesCount()}`;
        statsText += `\nğŸ¢ Active Attendance Sessions: ${AttendanceStateManager.getActiveStatesCount()}`;
        await sock.sendMessage(sender, { text: statsText });
      } else {
        await sock.sendMessage(sender, { 
          text: 'âŒ Command stats hanya tersedia untuk administrator.' 
        });
      }
      break;
      
    default:
      await sock.sendMessage(sender, { 
        text: 'âŒ Command tidak dikenal. Ketik /help untuk bantuan.' 
      });
  }
}

// Handle attendance menu choices when user is waiting for menu choice
async function handleAttendanceMenuChoice(sock, sender, user, userNumber, text) {
  if (AttendanceStateManager.isWaitingForMenuChoice(userNumber)) {
    await handleAttendanceChoice(sock, sender, user, userNumber, text);
    return true;
  }
  return false;
}

// Handle text messages with role-based logic
async function handleTextMessage(sock, sender, user, text) {
  const userNumber = sender.split('@')[0];
  
  // Check if user has role
  if (!user.role) {
    await sock.sendMessage(sender, { 
      text: `âŒ Anda belum memiliki role yang terdaftar.\n\nHubungi administrator untuk mendapatkan akses.\n\nğŸ“± Nomor Anda: ${userNumber}`
    });
    return;
  }
  
  try {
    // Handle OCR confirmation if user is waiting
    if (OCRStateManager.isWaitingForConfirmation(userNumber)) {
      await handleOCRConfirmation(sock, { key: { remoteJid: sender } }, userNumber, text);
      return;
    }
    
    // Handle attendance menu choice
    if (await handleAttendanceMenuChoice(sock, sender, user, userNumber, text)) {
      return;
    }
    
    // Handle attendance cancellation
    if ((text.toLowerCase() === 'batal' || text.toLowerCase() === 'cancel')) {
      // Check OCR mode first
      if (OCRStateManager.isWaitingForImage(userNumber)) {
        OCRStateManager.clearUserState(userNumber);
        await sock.sendMessage(sender, {
          text: 'âŒ Mode OCR dibatalkan.'
        });
        return;
      }
      
      // Check attendance mode
      if (AttendanceStateManager.isWaitingForLocation(userNumber) || 
          AttendanceStateManager.isWaitingForPhoto(userNumber) ||
          AttendanceStateManager.isWaitingForMenuChoice(userNumber)) {
        await handleAttendanceCancel(sock, sender, userNumber);
        return;
      }
    }
    
    // Handle numbered quick commands with role checking
    if (/^[0-9]$/.test(text.trim()) && 
        !OCRStateManager.isWaitingForConfirmation(userNumber) &&
        !OCRStateManager.isWaitingForImage(userNumber) &&
        !AttendanceStateManager.isInAttendanceMode(userNumber)) {
      
      const quickNumber = parseInt(text.trim());
      
      const canUse = await userCanUseQuickNumber(user.id, quickNumber);
      if (!canUse) {
        await sock.sendMessage(sender, { 
          text: `âŒ Quick command ${quickNumber} tidak tersedia untuk role ${user.role.emoji} ${user.role.display_name}` 
        });
        return;
      }
      
      messageStats.commands++;
      
      // Route based on role
      if (user.role.name === 'finance' || user.role.name === 'admin') {
        await handleQuickNumber(sock, sender, user, quickNumber);
      }
      return;
    }
    
    // Handle shortcut commands with role checking
    if (/^[mtgjsl]\s+/.test(text.toLowerCase()) &&
        !OCRStateManager.isWaitingForConfirmation(userNumber) &&
        !OCRStateManager.isWaitingForImage(userNumber) &&
        !AttendanceStateManager.isInAttendanceMode(userNumber)) {
      
      const shortcut = text.toLowerCase().charAt(0);
      
      const canUse = await userCanUseShortcut(user.id, shortcut);
      if (!canUse) {
        await sock.sendMessage(sender, { 
          text: `âŒ Shortcut "${shortcut}" tidak tersedia untuk role ${user.role.emoji} ${user.role.display_name}` 
        });
        return;
      }
      
      // Route based on shortcut and role
      if (['m', 't', 'g'].includes(shortcut) && (user.role.name === 'finance' || user.role.name === 'admin')) {
        await handleShortcutCommand(sock, sender, user, text);
      } else if (['j', 's'].includes(shortcut) && (user.role.name === 'cashier' || user.role.name === 'admin')) {
        await handleCashierShortcut(sock, sender, user, text);
      }
      return;
    }
    
    if (text.startsWith('/')) {
      // Handle commands with role checking
      messageStats.commands++;
      const [command, ...args] = text.slice(1).split(' ');
      await handleRoleBasedCommand(sock, sender, user, command, args);
    } else {
      // Don't process natural language when in special modes
      if (OCRStateManager.isWaitingForImage(userNumber) ||
          AttendanceStateManager.isInAttendanceMode(userNumber)) {
        // User is in special mode, provide guidance
        if (OCRStateManager.isWaitingForImage(userNumber)) {
          await sock.sendMessage(sender, { 
            text: 'ğŸ” Menunggu foto struk untuk di-scan.\nKirim foto atau ketik "batal" untuk membatalkan.' 
          });
        } else if (AttendanceStateManager.isWaitingForMenuChoice(userNumber)) {
          await sock.sendMessage(sender, { 
            text: 'ğŸ¢ Silakan pilih menu absensi:\nKetik: **masuk**, **pulang**, **status**, atau **rekap**\n\nAtau ketik "batal" untuk membatalkan.' 
          });
        } else if (AttendanceStateManager.isWaitingForLocation(userNumber)) {
          await sock.sendMessage(sender, { 
            text: 'ğŸ“ Menunggu lokasi untuk absensi.\nKirim lokasi atau ketik "batal" untuk membatalkan.' 
          });
        } else if (AttendanceStateManager.isWaitingForPhoto(userNumber)) {
          await sock.sendMessage(sender, { 
            text: 'ğŸ“¸ Menunggu foto selfie untuk absensi.\nKirim foto atau ketik "batal" untuk membatalkan.' 
          });
        }
        return;
      }
      
      // Handle natural language berdasarkan role
      await handleNaturalLanguage(sock, sender, user, text);
    }
    
  } catch (error) {
    logger.error('Error handling text message', { 
      from: userNumber, 
      role: user.role?.name,
      userId: user.id,
      error: error.message,
      stack: error.stack
    });
    
    await sock.sendMessage(sender, { text: 'âŒ Terjadi kesalahan sistem' });
  }
}

// Handle natural language berdasarkan role
async function handleNaturalLanguage(sock, sender, user, text) {
  const userRole = user.role.name;
  
  // Finance: parse transactions
  if (userRole === 'finance' || userRole === 'admin') {
    const parsed = parseTransaction(text);
    if (parsed) {
      const transactionId = await addTransaction(user.id, parsed);
      
      if (transactionId) {
        messageStats.transactions++;
        const sign = parsed.type === 'income' ? '+' : '-';
        
        const response = `âœ… *Transaksi Ditambahkan*

ğŸ“„ ID: #${transactionId}
ğŸ’° ${sign}${formatCurrency(parsed.amount)}
ğŸ“‚ ${parsed.category}
ğŸ“ ${parsed.description}

Ketik /saldo untuk cek saldo atau /chart untuk lihat grafik`;
        
        await sock.sendMessage(sender, { text: response });
        
        logger.info('Transaction processed successfully', {
          transactionId,
          userId: user.id,
          type: parsed.type,
          amount: parsed.amount,
          category: parsed.category,
          role: userRole,
          from: sender.split('@')[0]
        });
        return;
      } else {
        await sock.sendMessage(sender, { text: 'âŒ Gagal menambahkan transaksi' });
        return;
      }
    }
  }
  
  // Cashier: parse sales (future implementation)
  if (userRole === 'cashier' || userRole === 'admin') {
    // Parse sales transaction in future
    // For now, just show message
  }
  
  // If nothing matches, show role-specific help
  const roleSpecificGuidance = getRoleSpecificGuidance(user.role);
  await sock.sendMessage(sender, { 
    text: `â“ Tidak dapat memahami pesan untuk role ${user.role.emoji} ${user.role.display_name}\n\n${roleSpecificGuidance}\n\nKetik /help untuk panduan lengkap atau /menu untuk pilihan cepat.` 
  });
  
  logger.debug('Message parsing failed', { 
    from: sender.split('@')[0], 
    role: userRole,
    text: text.substring(0, 100) 
  });
}

// Get role-specific guidance
function getRoleSpecificGuidance(role) {
  switch (role.name) {
    case 'finance':
      return 'Contoh pesan keuangan:\nâ€¢ bayar makan 25000\nâ€¢ terima gaji 5jt\nâ€¢ m 25rb (shortcut makan)';
    case 'attendance':
      return 'Gunakan:\nâ€¢ /absen masuk - untuk absen masuk\nâ€¢ /absen pulang - untuk absen pulang';
    case 'cashier':
      return 'Fitur kasir:\nâ€¢ /jual - input penjualan\nâ€¢ /stok - cek stok\nâ€¢ /laporan - laporan harian';
    case 'admin':
      return 'Command admin:\nâ€¢ /role - kelola role\nâ€¢ /users - kelola user\nâ€¢ Semua fitur tersedia';
    default:
      return 'Ketik /help untuk melihat panduan.';
  }
}

// Generate role-specific help and menu functions
function generateFinanceHelp() {
  return `ğŸ’° *PANDUAN KEUANGAN*

ğŸ“Š *TRANSAKSI:*
- Bayar makan 25000
- Terima gaji 5jt
- m 25rb (makan cepat)
- t 15000 (transport cepat)
- g 5jt (gaji cepat)

ğŸ“ˆ *LAPORAN:*
- /saldo - Saldo hari ini
- /bulan - Laporan bulan ini
- /kategori - Summary kategori
- /chart - Grafik trend
- /pie - Pie chart pengeluaran

ğŸ” *UTILITAS:*
- /ocr - Scan struk belanja
- /hapus [ID] - Hapus transaksi
- /menu - Menu pilihan cepat

Contoh: "bayar makan siang 25000" atau "m 25rb"`;
}

function generateFinanceMenu() {
  return `ğŸ’° *MENU KEUANGAN*

ğŸ“Š *TRANSAKSI CEPAT:*
1ï¸âƒ£ Saldo Hari Ini (/saldo)
2ï¸âƒ£ Laporan Bulan (/bulan)  
3ï¸âƒ£ Kategori Pengeluaran (/kategori)

ğŸ“ˆ *GRAFIK:*
4ï¸âƒ£ Grafik Trend (/chart)
5ï¸âƒ£ Pie Chart (/pie)
6ï¸âƒ£ Perbandingan 3 Bulan (/compare)

âš¡ *INPUT CEPAT:*
7ï¸âƒ£ Makan (m [jumlah])
8ï¸âƒ£ Transport (t [jumlah])
9ï¸âƒ£ Gaji (g [jumlah])
0ï¸âƒ£ Hapus Transaksi (/hapus)

ğŸ” *LAINNYA:*
/ocr - Scan foto struk

Ketik angka atau command langsung!`;
}

function generateAttendanceHelp() {
  return `ğŸ¢ *PANDUAN ABSENSI*

âš¡ *COMMAND CEPAT:*
- /absen masuk - Absen masuk
- /absen pulang - Absen pulang
- /absen status - Status hari ini
- /absen rekap - Rekap bulanan

ğŸ“ *CARA ABSENSI:*
1. Ketik command absensi
2. Kirim lokasi (radius 300m)
3. Kirim foto selfie
4. Selesai!

ğŸ’¡ Tips: Pastikan GPS aktif dan dalam radius kantor`;
}

function generateAttendanceMenu() {
  return `ğŸ¢ *MENU ABSENSI*

âš¡ *ABSENSI CEPAT:*
- /absen masuk - Langsung absen masuk
- /absen pulang - Langsung absen pulang

ğŸ“Š *LAPORAN:*
- /absen status - Cek status hari ini  
- /absen rekap - Rekap bulanan

ğŸ“ Radius valid: 300m dari kantor
ğŸ“¸ Perlu foto untuk konfirmasi

Ketik command langsung!`;
}

function generateCashierHelp() {
  return `ğŸª *PANDUAN KASIR*

ğŸ’° *PENJUALAN:*
- /jual [item] [harga] - Input penjualan
- j [item] [harga] - Shortcut jual

ğŸ“¦ *STOK:*
- /stok [item] - Cek stok
- s [item] [jumlah] - Update stok

ğŸ“Š *LAPORAN:*
- /laporan - Laporan penjualan

ğŸ” *UTILITAS:*
- /ocr - Scan nota supplier

Fitur akan segera tersedia!`;
}

function generateCashierMenu() {
  return `ğŸª *MENU KASIR*

ğŸ’° *PENJUALAN:*
1ï¸âƒ£ Input Penjualan (/jual)
2ï¸âƒ£ Laporan Harian (/laporan)

ğŸ“¦ *STOK:*
3ï¸âƒ£ Cek Stok (/stok)
4ï¸âƒ£ Update Stok
5ï¸âƒ£ Stok Habis

ğŸ” *LAINNYA:*
/ocr - Scan nota

Fitur akan segera tersedia!`;
}

function generateRoleSpecificHelp(role) {
  switch (role.name) {
    case 'finance': return generateFinanceHelp();
    case 'attendance': return generateAttendanceHelp();
    case 'cashier': return generateCashierHelp();
    case 'admin': return getHelpText(); // Use original comprehensive help
    default: return 'Ketik /help untuk bantuan.';
  }
}

function generateRoleSpecificMenu(role) {
  switch (role.name) {
    case 'finance': return generateFinanceMenu();
    case 'attendance': return generateAttendanceMenu();
    case 'cashier': return generateCashierMenu();
    case 'admin': return generateQuickMenu(); // Use original comprehensive menu
    default: return 'Ketik /menu untuk melihat pilihan.';
  }
}

// Generate role-specific welcome message
function generateRoleSpecificWelcome(role) {
  const welcomeMessages = {
    finance: `ğŸ’° Selamat datang di Bot Keuangan!\n\nAnda terdaftar sebagai ${role.emoji} ${role.display_name}\n\nKetik /menu untuk pilihan cepat atau langsung input transaksi:\n"bayar makan 25000"`,
    
    attendance: `ğŸ¢ Selamat datang di Bot Absensi!\n\nAnda terdaftar sebagai ${role.emoji} ${role.display_name}\n\nKetik /absen masuk untuk memulai absensi atau /menu untuk pilihan lainnya.`,
    
    cashier: `ğŸª Selamat datang di Bot Kasir!\n\nAnda terdaftar sebagai ${role.emoji} ${role.display_name}\n\nKetik /menu untuk melihat fitur yang tersedia.`,
    
    admin: `ğŸ‘‘ Selamat datang Administrator!\n\nAnda memiliki akses ke semua fitur bot.\n\nKetik /help untuk panduan lengkap.`
  };
  
  return welcomeMessages[role.name] || `Selamat datang! Role: ${role.display_name}`;
}

// Main message handler with role-based logic
async function handleMessage(sock, m) {
  const message = m.messages[0];
  if (!message?.message || message.key.fromMe) return;
  
  const sender = message.key.remoteJid;
  const userNumber = sender.split('@')[0];
  
  // Increment total message counter
  messageStats.total++;
  
  // Ignore group messages completely
  if (isGroupChat(sender)) {
    messageStats.ignored.groups++;
    logger.debug('Group message ignored', { 
      groupId: sender.split('@')[0],
      totalGroupsIgnored: messageStats.ignored.groups
    });
    return;
  }
  
  // Ignore broadcast messages  
  if (isBroadcast(sender)) {
    messageStats.ignored.broadcasts++;
    logger.debug('Broadcast message ignored', {
      totalBroadcastsIgnored: messageStats.ignored.broadcasts
    });
    return;
  }
  
  // Only process private chats
  if (!isPrivateChat(sender)) {
    messageStats.ignored.nonPrivate++;
    logger.debug('Non-private chat ignored', { 
      chatType: sender.split('@')[1],
      from: sender.split('@')[0],
      totalNonPrivateIgnored: messageStats.ignored.nonPrivate
    });
    return;
  }
  
  // Check if user is authorized (has role) - replacing whitelist check
  if (!await isAuthorized(sender)) {
    messageStats.ignored.unauthorized++;
    logger.warn('Message from user without role silently ignored', { 
      from: userNumber,
      totalUnauthorizedIgnored: messageStats.ignored.unauthorized
    });
    
    // Send info message for unregistered users
    await sock.sendMessage(sender, {
      text: `ğŸ‘‹ Selamat datang!\n\nAnda belum terdaftar dalam sistem.\nHubungi administrator untuk mendapatkan akses.\n\nğŸ“± Nomor Anda: ${userNumber}`
    });
    return;
  }
  
  // Increment processed counter
  messageStats.processed++;
  
  const user = await getUser(sender);
  if (!user) {
    logger.error('Failed to get user', { sender });
    return;
  }
  
  // Welcome new users with role info
  if (user.role && !user.welcomed) {
    const welcomeMsg = generateRoleSpecificWelcome(user.role);
    await sock.sendMessage(sender, { text: welcomeMsg });
    
    logger.info('User welcomed with role', { 
      userNumber, 
      userId: user.id,
      role: user.role.name 
    });
  }
  
  try {
    // Handle different message types
    if (message.message.conversation || message.message.extendedTextMessage) {
      const text = message.message.conversation || message.message.extendedTextMessage.text;
      
      logger.info('Private text message received', { 
        from: userNumber, 
        userId: user.id,
        role: user.role?.name,
        textLength: text.length,
        textPreview: text.substring(0, 50) + (text.length > 50 ? '...' : '')
      });
      
      await handleTextMessage(sock, sender, user, text);
      
    } else if (message.message.imageMessage) {
      // Handle image message with role checking
      if (user.role && await userHasPermission(user.id, 'ocr')) {
        if (OCRStateManager.isWaitingForImage(userNumber)) {
          // User is in OCR mode, process the image
          await handleOCRImage(sock, message, userNumber);
        } else if (AttendanceStateManager.isWaitingForPhoto(userNumber)) {
          // User is in attendance mode, process the photo
          await handleAttendancePhoto(sock, message, userNumber);
        } else {
          // User sent image without OCR or attendance mode
          await sock.sendMessage(sender, {
            text: 'ğŸ“¸ **Foto diterima!**\n\n' +
                  'ğŸ” Untuk memproses dengan OCR, ketik **/ocr** terlebih dahulu\n' +
                  'ğŸ¢ Untuk absensi, ketik **/absen** terlebih dahulu\n\n' +
                  'ğŸ’¡ Atau gunakan /menu untuk fitur lainnya.'
          });
        }
      } else {
        await sock.sendMessage(sender, {
          text: `ğŸ“¸ Foto diterima, tapi role ${user.role?.emoji} ${user.role?.display_name} tidak memiliki akses untuk memproses foto.`
        });
      }
      
    } else if (message.message.locationMessage) {
      // Handle location message with role checking
      if (user.role && await userHasPermission(user.id, 'attendance')) {
        if (AttendanceStateManager.isWaitingForLocation(userNumber)) {
          await handleAttendanceLocation(sock, message, userNumber);
        } else {
          await sock.sendMessage(sender, {
            text: 'ğŸ“ **Lokasi diterima!**\n\n' +
                  'ğŸ¢ Untuk absensi, ketik **/absen** terlebih dahulu\n\n' +
                  'ğŸ’¡ Atau gunakan /menu untuk fitur lainnya.'
          });
        }
      } else {
        await sock.sendMessage(sender, {
          text: `ğŸ“ Lokasi diterima, tapi role ${user.role?.emoji} ${user.role?.display_name} tidak memiliki akses absensi.`
        });
      }
      
    } else {
      // Other message types
      logger.debug('Unsupported message type', { 
        userNumber,
        userId: user.id,
        role: user.role?.name,
        messageType: Object.keys(message.message)[0]
      });
    }
    
  } catch (error) {
    logger.error('Error handling message', { 
      from: userNumber, 
      userId: user.id,
      role: user.role?.name,
      error: error.message,
      stack: error.stack
    });
    
    await sock.sendMessage(sender, { text: 'âŒ Terjadi kesalahan sistem' });
  }
}

module.exports = {
  handleMessage
};